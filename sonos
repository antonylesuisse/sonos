#!/usr/bin/env python3
# by Antony Lesuisse 2020, public domain
import os
import select
import socket
import subprocess
import sys
from typing import Any, List, Optional, Union

import soco  # type: ignore[import]

HTTP_PORT = 8888
STREAM_NAME = "linux_to_sonos.flac"


def get_ip() -> Any:
    """
    Return the main IP address of the system

    Returns:
        Any: IP address
    """
    sock = socket.socket(socket.AF_INET, socket.SOCK_DGRAM)
    sock.settimeout(0)
    try:
        # doesn't even have to be reachable
        sock.connect(('10.255.255.255', 1))
        ip_addr = sock.getsockname()[0]
    except socket.gaierror:
        ip_addr = '127.0.0.1'
    finally:
        sock.close()
    return ip_addr


def run(cmd: str, shell: bool = False) -> str:
    """
    Function to run a command and return output

    Args:
        cmd (str): command to run
        shell (bool, optional): Whether the supplied command should utilise the shell.
            Defaults to False.

    Returns:
        str: _description_
    """
    command: Union[str, List[str]]
    if '|' in cmd:
        shell = True
        command = cmd
    else:
        command = cmd.split(' ')
    try:
        proc = subprocess.run(
            command,
            shell=shell,
            stdout=subprocess.PIPE,
            stderr=subprocess.STDOUT,
            check=True,
        )
    except subprocess.CalledProcessError as error:
        print(f'Command "{" ".join(error.cmd)}" failed: {error.stdout.decode("utf-8")}')
        return ''

    return proc.stdout.decode('utf-8').strip()


def sonos_discover(preferred: str = '') -> Optional[soco.core.SoCo]:
    """
    Discover a Sonos speaker

    Args:
        preferred (str, optional): IP of preferred Sonos device. Defaults to ''.

    Returns:
        Optional[soco.core.SoCo]: Sonos device found
    """
    for device in soco.discover():
        if not preferred:
            print(
                'No preferred Sonos device.  Returning the first one found: '
                f'{device.player_name}'
            )
            return device
        if preferred == device.ip_address:
            print(f'Preferred Sonos device found: {device.player_name}')
            return device

    return None


def sonos_play(sonos: soco.core.SoCo, volume: int) -> None:
    """
    Play content on the Sonos device

    Args:
        sonos (soco.core.SoCo): Sonos device
        volume (int): Volume level to set
    """
    sonos.clear_queue()
    sonos.add_uri_to_queue(f'http://{get_ip()}:{HTTP_PORT}/{STREAM_NAME}')
    sonos.play_from_queue(0)
    sonos.volume = volume
    sonos.play()


def get_all_audio_sinks() -> str:
    """
    Return the output from

    Returns:
        str: _description_
    """
    return run('pactl list sinks short | awk "{print $2}"')


def sonos_sink_exists() -> bool:
    """
    Check if the Sonos sink exists

    Returns:
        bool: True if found, False otherwise
    """
    return 'Sonos' in get_all_audio_sinks()


def pa_get_default_sink() -> str:
    """
    Get the "default" Pulse Audio sink

    Returns:
        str: PA sink name
    """
    return get_all_audio_sinks().split('\n')[-1]


def pa_sink_load(volume: int) -> bool:
    """
    Load the Pulse Audio sink for the Sonos

    Args:
        volume (int): Initial volume to set

    Returns:
        bool: True if we had to load the PA module.  False otherwise
    """
    module_loaded = False
    sonos_sink = sonos_sink_exists()
    if not sonos_sink:
        sink = pa_get_default_sink()
        if not sink:
            print('No audio sinks found')
            sys.exit(2)

        run(
            'pacmd load-module module-combine-sink sink_name=Sonos '
            f'sink_properties=device.description=Sonos slaves={sink} channels=2'
        )

        module_loaded = sonos_sink_exists()

    if sonos_sink:
        run(f'pactl set-sink-volume Sonos {volume}%')
        run('pactl set-default-sink Sonos')

    return module_loaded


def pa_sink_unload(module_loaded: bool, original_sink: str = '') -> None:
    """
    Unload the Pule Audio sink for the Sonos

    Args:
        module_loaded (bool): Set true if we should attempt to unload the PA module
        original_sink (str, optional): Reset the default sink back to this value. Defaults to ''.
    """
    sink = original_sink
    if not sink:
        sink = pa_get_default_sink()
    run(f'pactl set-default-sink {sink}')

    if module_loaded:
        run('pacmd unload-module module-combine-sink')


def vlc() -> subprocess.Popen:  # type: ignore[type-arg]
    """
    Use VLC to transcode and send the audio as a FLAC stream

    Returns:
        subprocess.Popen: process handle for VLC
    """
    command = (
        "/usr/bin/cvlc "
        "pulse://Sonos.monitor "
        "--sout #transcode{vcodec=none,acodec=flac,"
        "ab=1441,channels=2,samplerate=44100,scodec=none}:standard"
        f"{{access=http,dst=/{STREAM_NAME}}} "
        f'--http-host={get_ip()} '
        f'--http-port={HTTP_PORT}'
    )
    proc = subprocess.Popen(  # pylint: disable=consider-using-with
        command.split(" "),
        stdout=subprocess.PIPE,
        stderr=subprocess.STDOUT,
    )
    return proc


def silence() -> subprocess.Popen:  # type: ignore[type-arg]
    """
    Play a very quiet Pink noise to avoid sonos to cut when there is silence

    Returns:
        subprocess.Popen: process handle for ffplay
    """
    command = "ffplay -loglevel 24 -nodisp -autoexit -f lavfi -i anoisesrc=c=pink:r=44100:a=0.001"
    proc = subprocess.Popen(  # pylint: disable=consider-using-with
        command.split(" "),
        stdout=subprocess.PIPE,
        stderr=subprocess.PIPE,
    )
    return proc


def main() -> None:
    volume = 45
    if len(sys.argv) > 1:
        volume = int(sys.argv[1])
    module_loaded = pa_sink_load(volume)
    vlc_proc = vlc()
    silence_proc = silence()
    sonos = sonos_discover()

    sonos_play(sonos, volume)
    fds = [vlc_proc.stdout.fileno(), vlc_proc.stderr.fileno()]
    try:
        while 1:
            ret = select.select(fds, [], [])
            for descriptor in ret[0]:
                buf = os.read(descriptor, 8192).decode('utf8')
                print(buf)
    except KeyboardInterrupt as error:
        print(f'Caught {error}')
        print('killing vlc')
        vlc_proc.terminate()
        os.system('killall ffplay')
        print('killing ffplay')
        silence_proc.terminate()
        os.system('killall vlc')
        print('unload pasink')
        pa_sink_unload(module_loaded)


main()
